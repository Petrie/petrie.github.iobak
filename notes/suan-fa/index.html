<!DOCTYPE html>
<html lang="en" itemscope itemtype="http://schema.org/WebPage">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title> - Petrie&#39;s Home</title>
  

<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta name="MobileOptimized" content="width"/>
<meta name="HandheldFriendly" content="true"/>


<meta name="applicable-device" content="pc,mobile">

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="mobile-web-app-capable" content="yes">

<meta name="author" content="petrie" />
  <meta name="description" content="算法 POI相关 http://www.cnblogs.com/LBSer/p/4471742.html
排序算法 插入排序 直接插入排序 void print(int a[], int n ,int i){ cout&amp;lt;&amp;lt;i &amp;lt;&amp;lt;&amp;quot;:&amp;quot;; for(int j= 0; j&amp;lt;8; j&#43;&#43;){ cout&amp;lt;&amp;lt;a[j] &amp;lt;&amp;lt;&amp;quot; &amp;quot;; } cout&amp;lt;&amp;lt;endl; } void InsertSort(int arr[], int len) { int i,j,temp; for (i = 1 ; i &amp;lt; len ; i&#43;&#43; ) { temp = arr[i]; for (j = i; j &amp;gt; 0 &amp;amp;&amp;amp; arr[j-1] &amp;gt; temp; j--) { arr[j] = arr[j-1]; } arr[j] = temp; } } int main(){ int a[8] = {3,1,5,7,2,4,9,6}; InsertSort(a,8); print(a,8,8); }  希尔排序 void print(int a[], int n ,int i){ cout&amp;lt;&amp;lt;i &amp;lt;&amp;lt;&amp;quot;:&amp;quot;; for(int j= 0; j&amp;lt;8; j&#43;&#43;){ cout&amp;lt;&amp;lt;a[j] &amp;lt;&amp;lt;&amp;quot; &amp;quot;; } cout&amp;lt;&amp;lt;endl; } /** * 直接插入排序的一般形式 * * @param int dk 缩小增量，如果是直接插入排序，dk=1 * */ void ShellInsertSort(int a[], int n, int dk) { for(int i= dk; i&amp;lt;n; &#43;&#43;i){ if(a[i] &amp;lt; a[i-dk]){ //若第i个元素大于i-1元素，直接插入。小于的话，移动有序表后插入 int j = i-dk; int x = a[i]; //复制为哨兵，即存储待排序元素 a[i] = a[i-dk]; //首先后移一个元素 while(x &amp;lt; a[j]){ //查找在有序表的插入位置 a[j&#43;dk] = a[j]; j -= dk; //元素后移 } a[j&#43;dk] = x; //插入到正确位置 } print(a, n,i ); } } /** * 先按增量d（n/2,n为要排序数的个数进行希尔排序 * */ void shellSort(int a[], int n){ int dk = n/2; while( dk &amp;gt;= 1 ){ ShellInsertSort(a, n, dk); dk = dk/2; } } int main(){ int a[8] = {3,1,5,7,2,4,9,6}; //ShellInsertSort(a,8,1); //直接插入排序 shellSort(a,8); //希尔插入排序 print(a,8,8); }  选择排序 简单选择排序 void print(int a[], int n ,int i){ cout&amp;lt;&amp;lt;&amp;quot;第&amp;quot;&amp;lt;&amp;lt;i&#43;1 &amp;lt;&amp;lt;&amp;quot;趟 : &amp;quot;; for(int j= 0; j&amp;lt;8; j&#43;&#43;){ cout&amp;lt;&amp;lt;a[j] &amp;lt;&amp;lt;&amp;quot; &amp;quot;; } cout&amp;lt;&amp;lt;endl; } /** * 数组的最小值 * * @return int 数组的键值 */ int SelectMinKey(int a[], int n, int i) { int k = i; for(int j=i&#43;1 ;j&amp;lt; n; &#43;&#43;j) { if(a[k] &amp;gt; a[j]) k = j; } return k; } /** * 选择排序 * */ void selectSort(int a[], int n){ int key, tmp; for(int i = 0; i&amp;lt; n; &#43;&#43;i) { key = SelectMinKey(a, n,i); //选择最小的元素 if(key !" />

  <meta name="keywords" content="Petrie, golang, php, swoole" />






<meta name="generator" content="Hugo 0.54-DEV" />


<link rel="canonical" href="http://petrie.github.io/notes/suan-fa/" />



<link rel="icon" href="/favicon.ico" />











<link rel="stylesheet" href="/sass/jane.min.c8c1ff75dee09b44060a6c38f41b9036bac2512ccdb22d7f296cec12dc786375.css" integrity="sha256-yMH/dd7gm0QGCmw49BuQNrrCUSzNsi1/KWzsEtx4Y3U=" media="screen" crossorigin="anonymous">





<meta property="og:title" content="" />
<meta property="og:description" content="算法 POI相关 http://www.cnblogs.com/LBSer/p/4471742.html
排序算法 插入排序 直接插入排序 void print(int a[], int n ,int i){ cout&lt;&lt;i &lt;&lt;&quot;:&quot;; for(int j= 0; j&lt;8; j&#43;&#43;){ cout&lt;&lt;a[j] &lt;&lt;&quot; &quot;; } cout&lt;&lt;endl; } void InsertSort(int arr[], int len) { int i,j,temp; for (i = 1 ; i &lt; len ; i&#43;&#43; ) { temp = arr[i]; for (j = i; j &gt; 0 &amp;&amp; arr[j-1] &gt; temp; j--) { arr[j] = arr[j-1]; } arr[j] = temp; } } int main(){ int a[8] = {3,1,5,7,2,4,9,6}; InsertSort(a,8); print(a,8,8); }  希尔排序 void print(int a[], int n ,int i){ cout&lt;&lt;i &lt;&lt;&quot;:&quot;; for(int j= 0; j&lt;8; j&#43;&#43;){ cout&lt;&lt;a[j] &lt;&lt;&quot; &quot;; } cout&lt;&lt;endl; } /** * 直接插入排序的一般形式 * * @param int dk 缩小增量，如果是直接插入排序，dk=1 * */ void ShellInsertSort(int a[], int n, int dk) { for(int i= dk; i&lt;n; &#43;&#43;i){ if(a[i] &lt; a[i-dk]){ //若第i个元素大于i-1元素，直接插入。小于的话，移动有序表后插入 int j = i-dk; int x = a[i]; //复制为哨兵，即存储待排序元素 a[i] = a[i-dk]; //首先后移一个元素 while(x &lt; a[j]){ //查找在有序表的插入位置 a[j&#43;dk] = a[j]; j -= dk; //元素后移 } a[j&#43;dk] = x; //插入到正确位置 } print(a, n,i ); } } /** * 先按增量d（n/2,n为要排序数的个数进行希尔排序 * */ void shellSort(int a[], int n){ int dk = n/2; while( dk &gt;= 1 ){ ShellInsertSort(a, n, dk); dk = dk/2; } } int main(){ int a[8] = {3,1,5,7,2,4,9,6}; //ShellInsertSort(a,8,1); //直接插入排序 shellSort(a,8); //希尔插入排序 print(a,8,8); }  选择排序 简单选择排序 void print(int a[], int n ,int i){ cout&lt;&lt;&quot;第&quot;&lt;&lt;i&#43;1 &lt;&lt;&quot;趟 : &quot;; for(int j= 0; j&lt;8; j&#43;&#43;){ cout&lt;&lt;a[j] &lt;&lt;&quot; &quot;; } cout&lt;&lt;endl; } /** * 数组的最小值 * * @return int 数组的键值 */ int SelectMinKey(int a[], int n, int i) { int k = i; for(int j=i&#43;1 ;j&lt; n; &#43;&#43;j) { if(a[k] &gt; a[j]) k = j; } return k; } /** * 选择排序 * */ void selectSort(int a[], int n){ int key, tmp; for(int i = 0; i&lt; n; &#43;&#43;i) { key = SelectMinKey(a, n,i); //选择最小的元素 if(key !" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://petrie.github.io/notes/suan-fa/" />

<meta itemprop="name" content="">
<meta itemprop="description" content="算法 POI相关 http://www.cnblogs.com/LBSer/p/4471742.html
排序算法 插入排序 直接插入排序 void print(int a[], int n ,int i){ cout&lt;&lt;i &lt;&lt;&quot;:&quot;; for(int j= 0; j&lt;8; j&#43;&#43;){ cout&lt;&lt;a[j] &lt;&lt;&quot; &quot;; } cout&lt;&lt;endl; } void InsertSort(int arr[], int len) { int i,j,temp; for (i = 1 ; i &lt; len ; i&#43;&#43; ) { temp = arr[i]; for (j = i; j &gt; 0 &amp;&amp; arr[j-1] &gt; temp; j--) { arr[j] = arr[j-1]; } arr[j] = temp; } } int main(){ int a[8] = {3,1,5,7,2,4,9,6}; InsertSort(a,8); print(a,8,8); }  希尔排序 void print(int a[], int n ,int i){ cout&lt;&lt;i &lt;&lt;&quot;:&quot;; for(int j= 0; j&lt;8; j&#43;&#43;){ cout&lt;&lt;a[j] &lt;&lt;&quot; &quot;; } cout&lt;&lt;endl; } /** * 直接插入排序的一般形式 * * @param int dk 缩小增量，如果是直接插入排序，dk=1 * */ void ShellInsertSort(int a[], int n, int dk) { for(int i= dk; i&lt;n; &#43;&#43;i){ if(a[i] &lt; a[i-dk]){ //若第i个元素大于i-1元素，直接插入。小于的话，移动有序表后插入 int j = i-dk; int x = a[i]; //复制为哨兵，即存储待排序元素 a[i] = a[i-dk]; //首先后移一个元素 while(x &lt; a[j]){ //查找在有序表的插入位置 a[j&#43;dk] = a[j]; j -= dk; //元素后移 } a[j&#43;dk] = x; //插入到正确位置 } print(a, n,i ); } } /** * 先按增量d（n/2,n为要排序数的个数进行希尔排序 * */ void shellSort(int a[], int n){ int dk = n/2; while( dk &gt;= 1 ){ ShellInsertSort(a, n, dk); dk = dk/2; } } int main(){ int a[8] = {3,1,5,7,2,4,9,6}; //ShellInsertSort(a,8,1); //直接插入排序 shellSort(a,8); //希尔插入排序 print(a,8,8); }  选择排序 简单选择排序 void print(int a[], int n ,int i){ cout&lt;&lt;&quot;第&quot;&lt;&lt;i&#43;1 &lt;&lt;&quot;趟 : &quot;; for(int j= 0; j&lt;8; j&#43;&#43;){ cout&lt;&lt;a[j] &lt;&lt;&quot; &quot;; } cout&lt;&lt;endl; } /** * 数组的最小值 * * @return int 数组的键值 */ int SelectMinKey(int a[], int n, int i) { int k = i; for(int j=i&#43;1 ;j&lt; n; &#43;&#43;j) { if(a[k] &gt; a[j]) k = j; } return k; } /** * 选择排序 * */ void selectSort(int a[], int n){ int key, tmp; for(int i = 0; i&lt; n; &#43;&#43;i) { key = SelectMinKey(a, n,i); //选择最小的元素 if(key !">



<meta itemprop="wordCount" content="1343">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content=""/>
<meta name="twitter:description" content="算法 POI相关 http://www.cnblogs.com/LBSer/p/4471742.html
排序算法 插入排序 直接插入排序 void print(int a[], int n ,int i){ cout&lt;&lt;i &lt;&lt;&quot;:&quot;; for(int j= 0; j&lt;8; j&#43;&#43;){ cout&lt;&lt;a[j] &lt;&lt;&quot; &quot;; } cout&lt;&lt;endl; } void InsertSort(int arr[], int len) { int i,j,temp; for (i = 1 ; i &lt; len ; i&#43;&#43; ) { temp = arr[i]; for (j = i; j &gt; 0 &amp;&amp; arr[j-1] &gt; temp; j--) { arr[j] = arr[j-1]; } arr[j] = temp; } } int main(){ int a[8] = {3,1,5,7,2,4,9,6}; InsertSort(a,8); print(a,8,8); }  希尔排序 void print(int a[], int n ,int i){ cout&lt;&lt;i &lt;&lt;&quot;:&quot;; for(int j= 0; j&lt;8; j&#43;&#43;){ cout&lt;&lt;a[j] &lt;&lt;&quot; &quot;; } cout&lt;&lt;endl; } /** * 直接插入排序的一般形式 * * @param int dk 缩小增量，如果是直接插入排序，dk=1 * */ void ShellInsertSort(int a[], int n, int dk) { for(int i= dk; i&lt;n; &#43;&#43;i){ if(a[i] &lt; a[i-dk]){ //若第i个元素大于i-1元素，直接插入。小于的话，移动有序表后插入 int j = i-dk; int x = a[i]; //复制为哨兵，即存储待排序元素 a[i] = a[i-dk]; //首先后移一个元素 while(x &lt; a[j]){ //查找在有序表的插入位置 a[j&#43;dk] = a[j]; j -= dk; //元素后移 } a[j&#43;dk] = x; //插入到正确位置 } print(a, n,i ); } } /** * 先按增量d（n/2,n为要排序数的个数进行希尔排序 * */ void shellSort(int a[], int n){ int dk = n/2; while( dk &gt;= 1 ){ ShellInsertSort(a, n, dk); dk = dk/2; } } int main(){ int a[8] = {3,1,5,7,2,4,9,6}; //ShellInsertSort(a,8,1); //直接插入排序 shellSort(a,8); //希尔插入排序 print(a,8,8); }  选择排序 简单选择排序 void print(int a[], int n ,int i){ cout&lt;&lt;&quot;第&quot;&lt;&lt;i&#43;1 &lt;&lt;&quot;趟 : &quot;; for(int j= 0; j&lt;8; j&#43;&#43;){ cout&lt;&lt;a[j] &lt;&lt;&quot; &quot;; } cout&lt;&lt;endl; } /** * 数组的最小值 * * @return int 数组的键值 */ int SelectMinKey(int a[], int n, int i) { int k = i; for(int j=i&#43;1 ;j&lt; n; &#43;&#43;j) { if(a[k] &gt; a[j]) k = j; } return k; } /** * 选择排序 * */ void selectSort(int a[], int n){ int key, tmp; for(int i = 0; i&lt; n; &#43;&#43;i) { key = SelectMinKey(a, n,i); //选择最小的元素 if(key !"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->




</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Petrie</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="http://petrie.github.io/">Home</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="http://petrie.github.io/post/">Archives</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="http://petrie.github.io/tags/">Tags</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="http://petrie.github.io/categories/">Categories</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="http://petrie.github.io/about/">About</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://gohugo.io" rel="noopener" target="_blank">
              external-link
              
              <i class="iconfont">
                <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M623.36 272.96 473.216 423.04C467.2 429.056 467.072 438.656 472.896 444.416c0 0-6.72-6.656 1.6 1.6C496.064 467.648 528.64 500.224 528.64 500.224 534.464 506.048 544 505.856 550.016 499.904l150.08-150.144 67.328 66.432c9.024 8.96 27.456 4.544 30.4-8.96 19.968-92.608 46.656-227.52 46.656-227.52 6.848-34.496-16.192-56.704-49.92-49.92 0 0-134.656 26.816-227.328 46.784C560.32 178.048 556.352 182.272 554.752 187.136c-3.2 6.208-3.008 14.208 3.776 20.992L623.36 272.96z"></path>
  <path d="M841.152 457.152c-30.528 0-54.784 24.512-54.784 54.656l0 274.752L237.696 786.56 237.696 237.696l206.016 0c6.656 0 10.752 0 13.248 0C487.68 237.696 512 213.184 512 182.848 512 152.32 487.36 128 456.96 128L183.04 128C153.216 128 128 152.576 128 182.848c0 3.136 0.256 6.272 0.768 9.28C128.256 195.136 128 198.272 128 201.408l0 639.488c0 0.064 0 0.192 0 0.256 0 0.128 0 0.192 0 0.32 0 30.528 24.512 54.784 54.784 54.784l646.976 0c6.592 0 9.728 0 11.712 0 28.736 0 52.928-22.976 54.464-51.968C896 843.264 896 842.304 896 841.344l0-20.352L896 561.408 896 512.128C896 481.792 871.424 457.152 841.152 457.152z"></path>
</svg>

              </i>
            </a>
          
        
      </li>
    
  </ul>
</nav>


  
    






  <link rel="stylesheet" href="/lib/photoswipe/photoswipe.min.css" />
  <link rel="stylesheet" href="/lib/photoswipe/default-skin/default-skin.min.css" />




<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>

  

  

  <header id="header" class="header container">
    <div class="logo-wrapper">
  <a href="/" class="logo">
    
      Petrie
    
  </a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="http://petrie.github.io/">Home</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="http://petrie.github.io/post/">Archives</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="http://petrie.github.io/tags/">Tags</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="http://petrie.github.io/categories/">Categories</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="http://petrie.github.io/about/">About</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://gohugo.io" rel="noopener" target="_blank">
              external-link
              
              <i class="iconfont">
                <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M623.36 272.96 473.216 423.04C467.2 429.056 467.072 438.656 472.896 444.416c0 0-6.72-6.656 1.6 1.6C496.064 467.648 528.64 500.224 528.64 500.224 534.464 506.048 544 505.856 550.016 499.904l150.08-150.144 67.328 66.432c9.024 8.96 27.456 4.544 30.4-8.96 19.968-92.608 46.656-227.52 46.656-227.52 6.848-34.496-16.192-56.704-49.92-49.92 0 0-134.656 26.816-227.328 46.784C560.32 178.048 556.352 182.272 554.752 187.136c-3.2 6.208-3.008 14.208 3.776 20.992L623.36 272.96z"></path>
  <path d="M841.152 457.152c-30.528 0-54.784 24.512-54.784 54.656l0 274.752L237.696 786.56 237.696 237.696l206.016 0c6.656 0 10.752 0 13.248 0C487.68 237.696 512 213.184 512 182.848 512 152.32 487.36 128 456.96 128L183.04 128C153.216 128 128 152.576 128 182.848c0 3.136 0.256 6.272 0.768 9.28C128.256 195.136 128 198.272 128 201.408l0 639.488c0 0.064 0 0.192 0 0.256 0 0.128 0 0.192 0 0.32 0 30.528 24.512 54.784 54.784 54.784l646.976 0c6.592 0 9.728 0 11.712 0 28.736 0 52.928-22.976 54.464-51.968C896 843.264 896 842.304 896 841.344l0-20.352L896 561.408 896 512.128C896 481.792 871.424 457.152 841.152 457.152z"></path>
</svg>

              </i>
            </a>
          

        

      </li>
    
    
  </ul>
</nav>

  </header>

  <div id="mobile-panel">
    <main id="main" class="main bg-llight">
      <div class="content-wrapper">
        <div id="content" class="content container">
          <article class="post bg-white">
  
  <header class="post-header">
    <h1 class="post-title"></h1>
    
    <div class="post-meta">
      <time datetime="0001-01-01" class="post-time">
        0001-01-01
      </time>
    </div>
  </header>

  
  
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Table of Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
<ul>
<li><a href="#算法">算法</a>
<ul>
<li><a href="#poi相关">POI相关</a></li>
<li><a href="#排序算法">排序算法</a>
<ul>
<li><a href="#插入排序">插入排序</a>
<ul>
<li><a href="#直接插入排序">直接插入排序</a></li>
<li><a href="#希尔排序">希尔排序</a></li>
</ul></li>
<li><a href="#选择排序">选择排序</a>
<ul>
<li><a href="#简单选择排序">简单选择排序</a></li>
<li><a href="#简单选择排序的改进版-二元选择排序">简单选择排序的改进版：二元选择排序</a></li>
<li><a href="#堆排序">堆排序</a></li>
</ul></li>
<li><a href="#交换排序">交换排序</a>
<ul>
<li><a href="#冒泡排序">冒泡排序</a></li>
<li><a href="#冒泡排序算法的改进">冒泡排序算法的改进</a></li>
<li><a href="#改进二">改进二</a></li>
<li><a href="#快速排序">快速排序</a></li>
</ul></li>
<li><a href="#归并排序">归并排序</a></li>
<li><a href="#基数排序">基数排序</a></li>
</ul></li>
<li><a href="#查询算法">查询算法</a>
<ul>
<li><a href="#顺序查找">顺序查找</a></li>
<li><a href="#二分查找">二分查找</a></li>
<li><a href="#二叉查找树">二叉查找树</a></li>
<li><a href="#2-3查找树">2-3查找树</a></li>
<li><a href="#红黑树">红黑树</a>
<ul>
<li><a href="#基本思想">基本思想</a></li>
<li><a href="#红黑树的定义">红黑树的定义：</a></li>
<li><a href="#应用场景">应用场景</a></li>
</ul></li>
<li><a href="#b树">B树</a>
<ul>
<li><a href="#应用场景-1">应用场景</a></li>
</ul></li>
<li><a href="#b-树">B+树</a></li>
<li><a href="#跳跃表">跳跃表</a></li>
</ul></li>
<li><a href="#树">树</a></li>
<li><a href="#常见算法">常见算法</a>
<ul>
<li>
<ul>
<li><a href="#倒排索引">倒排索引</a></li>
</ul></li>
<li><a href="#斐波那契数">斐波那契数</a>
<ul>
<li><a href="#循环迭代方法">循环迭代方法</a></li>
<li><a href="#递归方法">递归方法</a></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</nav>
  </div>
</div>

  
  <div class="post-content">
      

<h1 id="算法">算法</h1>

<h2 id="poi相关">POI相关</h2>

<p><a href="http://www.cnblogs.com/LBSer/p/4471742.html">http://www.cnblogs.com/LBSer/p/4471742.html</a></p>

<h2 id="排序算法">排序算法</h2>

<h3 id="插入排序">插入排序</h3>

<h4 id="直接插入排序">直接插入排序</h4>

<pre><code class="language-c">void print(int a[], int n ,int i){  
    cout&lt;&lt;i &lt;&lt;&quot;:&quot;;  
    for(int j= 0; j&lt;8; j++){  
        cout&lt;&lt;a[j] &lt;&lt;&quot; &quot;;  
    }  
    cout&lt;&lt;endl;  
}  

void InsertSort(int arr[], int len)
{
    int i,j,temp;

    for (i = 1 ; i &lt; len ; i++ )
    {
        temp = arr[i];

        for (j = i; j &gt; 0 &amp;&amp; arr[j-1] &gt; temp; j--)
        {
            arr[j] = arr[j-1];
        }

        arr[j] = temp;
    }
}

int main(){  
    int a[8] = {3,1,5,7,2,4,9,6};  
    InsertSort(a,8);  
    print(a,8,8);  
}
</code></pre>

<h4 id="希尔排序">希尔排序</h4>

<pre><code class="language-c">void print(int a[], int n ,int i){  
    cout&lt;&lt;i &lt;&lt;&quot;:&quot;;  
    for(int j= 0; j&lt;8; j++){  
        cout&lt;&lt;a[j] &lt;&lt;&quot; &quot;;  
    }  
    cout&lt;&lt;endl;  
}  
/** 
 * 直接插入排序的一般形式 
 * 
 * @param int dk 缩小增量，如果是直接插入排序，dk=1 
 * 
 */  

void ShellInsertSort(int a[], int n, int dk)  
{  
    for(int i= dk; i&lt;n; ++i){  
        if(a[i] &lt; a[i-dk]){          //若第i个元素大于i-1元素，直接插入。小于的话，移动有序表后插入  
            int j = i-dk;     
            int x = a[i];           //复制为哨兵，即存储待排序元素  
            a[i] = a[i-dk];         //首先后移一个元素  
            while(x &lt; a[j]){     //查找在有序表的插入位置  
                a[j+dk] = a[j];  
                j -= dk;             //元素后移  
            }  
            a[j+dk] = x;            //插入到正确位置  
        }  
        print(a, n,i );  
    }  

}  

/** 
 * 先按增量d（n/2,n为要排序数的个数进行希尔排序 
 * 
 */  
void shellSort(int a[], int n){  

    int dk = n/2;  
    while( dk &gt;= 1  ){  
        ShellInsertSort(a, n, dk);  
        dk = dk/2;  
    }  
}  
int main(){  
    int a[8] = {3,1,5,7,2,4,9,6};  
    //ShellInsertSort(a,8,1); //直接插入排序  
    shellSort(a,8);           //希尔插入排序  
    print(a,8,8);  
}
</code></pre>

<h3 id="选择排序">选择排序</h3>

<h4 id="简单选择排序">简单选择排序</h4>

<pre><code class="language-c">void print(int a[], int n ,int i){  
    cout&lt;&lt;&quot;第&quot;&lt;&lt;i+1 &lt;&lt;&quot;趟 : &quot;;  
    for(int j= 0; j&lt;8; j++){  
        cout&lt;&lt;a[j] &lt;&lt;&quot;  &quot;;  
    }  
    cout&lt;&lt;endl;  
}  
/** 
 * 数组的最小值 
 * 
 * @return int 数组的键值 
 */  
int SelectMinKey(int a[], int n, int i)  
{  
    int k = i;  
    for(int j=i+1 ;j&lt; n; ++j) {  
        if(a[k] &gt; a[j]) k = j;  
    }  
    return k;  
}  

/** 
 * 选择排序 
 * 
 */  
void selectSort(int a[], int n){  
    int key, tmp;  
    for(int i = 0; i&lt; n; ++i) {  
        key = SelectMinKey(a, n,i);           //选择最小的元素  
        if(key != i){  
            tmp = a[i];  a[i] = a[key]; a[key] = tmp; //最小元素与第i位置元素互换  
        }  
        print(a,  n , i);  
    }  
}  
int main(){  
    int a[8] = {3,1,5,7,2,4,9,6};  
    cout&lt;&lt;&quot;初始值：&quot;;  
    for(int j= 0; j&lt;8; j++){  
        cout&lt;&lt;a[j] &lt;&lt;&quot;  &quot;;  
    }  
    cout&lt;&lt;endl&lt;&lt;endl;  
    selectSort(a, 8);  
    print(a,8,8);  
}
</code></pre>

<h4 id="简单选择排序的改进版-二元选择排序">简单选择排序的改进版：二元选择排序</h4>

<pre><code class="language-c">void SelectSort(int r[],int n) {  
    int i ,j , min ,max, tmp;  
    for (i=1 ;i &lt;= n/2;i++) {    
        // 做不超过n/2趟选择排序   
        min = i; max = i ; //分别记录最大和最小关键字记录位置  
        for (j= i+1; j&lt;= n-i; j++) {  
            if (r[j] &gt; r[max]) {   
                max = j ; continue ;   
            }    
            if (r[j]&lt; r[min]) {   
                min = j ;   
            }     
      }    
      //该交换操作还可分情况讨论以提高效率  
      tmp = r[i-1]; r[i-1] = r[min]; r[min] = tmp;  
      tmp = r[n-i]; r[n-i] = r[max]; r[max] = tmp;   

    }   
}
</code></pre>

<h4 id="堆排序">堆排序</h4>

<p><a href="http://bubkoo.com/2014/01/14/sort-algorithm/heap-sort/">http://bubkoo.com/2014/01/14/sort-algorithm/heap-sort/</a></p>

<h3 id="交换排序">交换排序</h3>

<h4 id="冒泡排序">冒泡排序</h4>

<pre><code class="language-c">void bubbleSort(int a[], int n){  
    for(int i =0 ; i&lt; n-1; ++i) {  
        for(int j = 0; j &lt; n-i-1; ++j) {  
            if(a[j] &gt; a[j+1])  
            {  
                int tmp = a[j] ; a[j] = a[j+1] ;  a[j+1] = tmp;  
            }  
        }  
    }  
}
</code></pre>

<h4 id="冒泡排序算法的改进">冒泡排序算法的改进</h4>

<pre><code class="language-c">void Bubble_1 ( int r[], int n) {  
    int i= n -1;  //初始时,最后位置保持不变  
    while ( i&gt; 0) {   
        int pos= 0; //每趟开始时,无记录交换  
        for (int j= 0; j&lt; i; j++) { 
            if (r[j]&gt; r[j+1]) {  
                pos= j; //记录交换的位置   
                int tmp = r[j]; r[j]=r[j+1];r[j+1]=tmp;  
            }   
        }
        i= pos; //为下一趟排序作准备  
     }   
}
</code></pre>

<h4 id="改进二">改进二</h4>

<pre><code class="language-c">void Bubble_2 ( int r[], int n){  
    int low = 0;   
    int high= n -1; //设置变量的初始值  
    int tmp,j;  
    while (low &lt; high) {  
        for (j= low; j&lt; high; ++j) //正向冒泡,找到最大者  
            if (r[j]&gt; r[j+1]) {  
                tmp = r[j]; r[j]=r[j+1];r[j+1]=tmp;  
            }   
        --high;                 //修改high值, 前移一位  
        for ( j=high; j&gt;low; --j) //反向冒泡,找到最小者  
            if (r[j]&lt;r[j-1]) {  
                tmp = r[j]; r[j]=r[j-1];r[j-1]=tmp;  
            }  
        ++low;                  //修改low值,后移一位  
    }   
}
</code></pre>

<h4 id="快速排序">快速排序</h4>

<pre><code class="language-c">void print(int a[], int n){  
    for(int j= 0; j&lt;n; j++){  
        cout&lt;&lt;a[j] &lt;&lt;&quot;  &quot;;  
    }  
    cout&lt;&lt;endl;  
}  

void swap(int *a, int *b)  
{  
    int tmp = *a;  
    *a = *b;  
    *b = tmp;  
}  

int partition(int a[], int low, int high)  
{  
    int privotKey = a[low];                             //基准元素  
    while(low &lt; high){                                   //从表的两端交替地向中间扫描  
        while(low &lt; high  &amp;&amp; a[high] &gt;= privotKey) --high;  //从high 所指位置向前搜索，至多到low+1 位置。将比基准元素小的交换到低端  
        swap(&amp;a[low], &amp;a[high]);  
        while(low &lt; high  &amp;&amp; a[low] &lt;= privotKey ) ++low;  
        swap(&amp;a[low], &amp;a[high]);  
    }  
    print(a,10);  
    return low;  
}  


void quickSort(int a[], int low, int high){  
    if(low &lt; high){  
        int privotLoc = partition(a,  low,  high);  //将表一分为二  
        quickSort(a,  low,  privotLoc -1);          //递归对低子表递归排序  
        quickSort(a,   privotLoc + 1, high);        //递归对高子表递归排序  
    }  
}  

int main(){  
    int a[10] = {3,1,5,7,2,4,9,6,10,8};  
    cout&lt;&lt;&quot;初始值：&quot;;  
    print(a,10);  
    quickSort(a,0,9);  
    cout&lt;&lt;&quot;结果：&quot;;  
    print(a,10);  

}
</code></pre>

<p>快速排序改进</p>

<pre><code class="language-c">void print(int a[], int n){  
    for(int j= 0; j&lt;n; j++){  
        cout&lt;&lt;a[j] &lt;&lt;&quot;  &quot;;  
    }  
    cout&lt;&lt;endl;  
}  

void swap(int *a, int *b)  
{  
    int tmp = *a;  
    *a = *b;  
    *b = tmp;  
}  

int partition(int a[], int low, int high)  
{  
    int privotKey = a[low];                 //基准元素  
    while(low &lt; high){                   //从表的两端交替地向中间扫描  
        while(low &lt; high  &amp;&amp; a[high] &gt;= privotKey) --high; //从high 所指位置向前搜索，至多到low+1 位置。将比基准元素小的交换到低端  
        swap(&amp;a[low], &amp;a[high]);  
        while(low &lt; high  &amp;&amp; a[low] &lt;= privotKey ) ++low;  
        swap(&amp;a[low], &amp;a[high]);  
    }  
    print(a,10);  
    return low;  
}  


void qsort_improve(int r[ ],int low,int high, int k){  
    if( high -low &gt; k ) { //长度大于k时递归, k为指定的数  
        int pivot = partition(r, low, high); // 调用的Partition算法保持不变  
        qsort_improve(r, low, pivot - 1,k);  
        qsort_improve(r, pivot + 1, high,k);  
    }   
}   
void quickSort(int r[], int n, int k){  
    qsort_improve(r,0,n,k);//先调用改进算法Qsort使之基本有序  

    //再用插入排序对基本有序序列排序  
    for(int i=1; i&lt;=n;i ++){  
        int tmp = r[i];   
        int j=i-1;  
        while(tmp &lt; r[j]){  
            r[j+1]=r[j]; j=j-1;   
        }  
        r[j+1] = tmp;  
    }   

}   



int main(){  
    int a[10] = {3,1,5,7,2,4,9,6,10,8};  
    cout&lt;&lt;&quot;初始值：&quot;;  
    print(a,10);  
    quickSort(a,9,4);  
    cout&lt;&lt;&quot;结果：&quot;;  
    print(a,10);  

}
</code></pre>

<h3 id="归并排序">归并排序</h3>

<ul>
<li>迭代版</li>
</ul>

<pre><code class="language-c">  int min(int x, int y) {
      return x &lt; y ? x : y;
  }
  void merge_sort(int arr[], int len) {
      int* a = arr;
      int* b = (int*) malloc(len * sizeof(int));
      int seg, start;
      for (seg = 1; seg &lt; len; seg += seg) {
          for (start = 0; start &lt; len; start += seg + seg) {
              int low = start, mid = min(start + seg, len), high = min(start + seg + seg, len);
              int k = low;
              int start1 = low, end1 = mid;
              int start2 = mid, end2 = high;
              while (start1 &lt; end1 &amp;&amp; start2 &lt; end2)
                  b[k++] = a[start1] &lt; a[start2] ? a[start1++] : a[start2++];
              while (start1 &lt; end1)
                  b[k++] = a[start1++];
              while (start2 &lt; end2)
                  b[k++] = a[start2++];
          }
          int* temp = a;
          a = b;
          b = temp;
      }
      if (a != arr) {
          int i;
          for (i = 0; i &lt; len; i++)
              b[i] = a[i];
          b = a;
      }
      free(b);
  }
</code></pre>

<ul>
<li>递归版</li>
</ul>

<pre><code class="language-c">  void merge_sort_recursive(int arr[], int reg[], int start, int end) {
      if (start &gt;= end)
          return;
      int len = end - start, mid = (len &gt;&gt; 1) + start;
      int start1 = start, end1 = mid;
      int start2 = mid + 1, end2 = end;
      merge_sort_recursive(arr, reg, start1, end1);
      merge_sort_recursive(arr, reg, start2, end2);
      int k = start;
      while (start1 &lt;= end1 &amp;&amp; start2 &lt;= end2)
          reg[k++] = arr[start1] &lt; arr[start2] ? arr[start1++] : arr[start2++];
      while (start1 &lt;= end1)
          reg[k++] = arr[start1++];
      while (start2 &lt;= end2)
          reg[k++] = arr[start2++];
      for (k = start; k &lt;= end; k++)
          arr[k] = reg[k];
  }
  void merge_sort(int arr[], const int len) {
      int reg[len];
      merge_sort_recursive(arr, reg, 0, len - 1);
  }
</code></pre>

<p>​</p>

<h3 id="基数排序">基数排序</h3>

<h2 id="查询算法">查询算法</h2>

<h3 id="顺序查找">顺序查找</h3>

<pre><code class="language-c">//顺序查找
int SequenceSearch(int a[], int value, int n)
{
    int i;
    for(i=0; i&lt;n; i++)
        if(a[i]==value)
            return i;
    return -1;
}
</code></pre>

<h3 id="二分查找">二分查找</h3>

<pre><code class="language-c">//二分查找（折半查找），版本1
int BinarySearch1(int a[], int value, int n)
{
    int low, high, mid;
    low = 0;
    high = n-1;
    while(low&lt;=high)
    {
        mid = (low+high)/2;
        if(a[mid]==value)
            return mid;
        if(a[mid]&gt;value)
            high = mid-1;
        if(a[mid]&lt;value)
            low = mid+1;
    }
    return -1;
}

//二分查找，递归版本
int BinarySearch2(int a[], int value, int low, int high)
{
    int mid = low+(high-low)/2;
    if(a[mid]==value)
        return mid;
    if(a[mid]&gt;value)
        return BinarySearch2(a, value, low, mid-1);
    if(a[mid]&lt;value)
        return BinarySearch2(a, value, mid+1, high);
}
</code></pre>

<h3 id="二叉查找树">二叉查找树</h3>

<p><strong>二叉查找树</strong>（BinarySearch Tree，也叫二叉搜索树，或称二叉排序树Binary Sort Tree）或者是一棵空树，或者是具有下列性质的二叉树：</p>

<ul>
<li>若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li>任意节点的左、右子树也分别为二叉查找树。</li>
</ul>

<p><strong>二叉查找树性质</strong>：<strong>对二叉查找树进行中序遍历，即可得到有序的数列。</strong></p>

<h3 id="2-3查找树">2-3查找树</h3>

<p><strong>2-3查找树定义</strong>：和二叉树不一样，2-3树运行每个节点保存1个或者两个的值。对于普通的2节点(2-node)，他保存1个key和左右两个子节点。对应3节点(3-node)，保存两个Key，2-3查找树的定义如下：</p>

<ul>
<li>要么为空，要么：</li>
<li>对于2节点，该节点保存一个key及对应value，以及两个指向左右节点的节点，左节点也是一个2-3节点，所有的值都比key要小，右节点也是一个2-3节点，所有的值比key要大。</li>
<li>对于3节点，该节点保存两个key及对应value，以及三个指向左中右的节点。左节点也是一个2-3节点，所有的值均比两个key中的最小的key还要小；中间节点也是一个2-3节点，中间节点的key值在两个跟节点key值之间；右节点也是一个2-3节点，节点的所有key值比两个key中的最大的key还要大。</li>
</ul>

<h3 id="红黑树">红黑树</h3>

<p>2-3查找树能保证在插入元素之后能保持树的平衡状态，最坏情况下即所有的子节点都是2-node，树的高度为lgn，从而保证了最坏情况下的时间复杂度。但是2-3树实现起来比较复杂，于是就有了一种简单实现2-3树的数据结构，即红黑树（Red-Black Tree）。</p>

<h4 id="基本思想">基本思想</h4>

<p>红黑树的思想就是对2-3查找树进行编码，尤其是对2-3查找树中的3-nodes节点添加额外的信息。红黑树中将节点之间的链接分为两种不同类型，红色链接，他用来链接两个2-nodes节点来表示一个3-nodes节点。黑色链接用来链接普通的2-3节点。特别的，使用红色链接的两个2-nodes来表示一个3-nodes节点，并且向左倾斜，即一个2-node是另一个2-node的左子节点。这种做法的好处是查找的时候不用做任何修改，和普通的二叉查找树相同。</p>

<h4 id="红黑树的定义">红黑树的定义：</h4>

<p>红黑树是一种具有红色和黑色链接的平衡查找树，同时满足：</p>

<ul>
<li>红色节点向左倾斜</li>
<li>一个节点不可能有两个红色链接</li>
<li>整个树完全黑色平衡，即从根节点到所以叶子结点的路径上，黑色链接的个数都相同。</li>
</ul>

<h4 id="应用场景">应用场景</h4>

<ul>
<li>著名的linux进程调度<a href="https://en.wikipedia.org/wiki/Completely_Fair_Scheduler">Completely Fair Scheduler</a>,用红黑树管理进程控制块</li>
<li>epoll在内核中的实现，用红黑树管理事件块</li>
<li>nginx中，用红黑树管理timer等</li>
<li>Java的TreeMap实现</li>
</ul>

<h3 id="b树">B树</h3>

<p><strong>B树</strong>可以看作是对2-3查找树的一种扩展，即他允许每个节点有M-1个子节点。</p>

<ul>
<li>根节点至少有两个子节点</li>
<li>每个节点有M-1个key，并且以升序排列</li>
<li>位于M-1和M key的子节点的值位于M-1 和M key对应的Value之间</li>
<li>其它节点至少有M/2个子节点</li>
</ul>

<h4 id="应用场景-1">应用场景</h4>

<ul>
<li>文件系统及数据库场景</li>
<li>​</li>
</ul>

<h3 id="b-树">B+树</h3>

<p><strong>B+</strong>树是对B树的一种变形树，它与B树的差异在于：</p>

<ul>
<li>有k个子结点的结点必然有k个关键码；</li>
<li>非叶结点仅具有索引作用，跟记录有关的信息均存放在叶结点中。</li>
<li>树的所有叶结点构成一个有序链表，可以按照关键码排序的次序遍历全部记录。</li>
</ul>

<p><strong>B和B+树的区别在于，B+树的非叶子结点只包含导航信息，不包含实际的值，所有的叶子结点和相连的节点使用链表相连，便于区间查找和遍历。</strong></p>

<p><strong>但是B树也有优点，其优点在于，由于B树的每一个节点都包含key和value，因此经常访问的元素可能离根节点更近，因此访问也更迅速。</strong></p>

<h3 id="跳跃表">跳跃表</h3>

<h2 id="树">树</h2>

<ul>
<li>二叉查找树又称二叉搜索树、有序二叉树（英语：ordered binary tree），排序二叉树</li>
<li>平衡树（自平衡二叉查找树）是计算机科学中的一类改进的二叉查找树。

<ul>
<li><a href="https://zh.wikipedia.org/wiki/AVL%E6%A0%91">AVL树</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91">红黑树</a></li>
<li><a href="https://zh.wikipedia.org/wiki/2-3%E6%A0%91">2-3树</a></li>
</ul></li>
</ul>

<h2 id="常见算法">常见算法</h2>

<blockquote>
<p><a href="http://www.geeksforgeeks.org/top-10-algorithms-in-interview-questions/">http://www.geeksforgeeks.org/top-10-algorithms-in-interview-questions/</a></p>
</blockquote>

<h4 id="倒排索引">倒排索引</h4>

<h3 id="斐波那契数">斐波那契数</h3>

<h4 id="循环迭代方法">循环迭代方法</h4>

<pre><code class="language-php">&lt;?php
  function fib_interation($n){
    $fib = array();
      if($n &lt; 0){
      return 0;
      }
      for($fib[0] = 0, fib[1] = 1, $i = 2; $i&lt;=$n; $i++){
      $fib[$i] = $fib[$i - 1] + $fib[$i-2];
      }

      return $fib[$n];
  }
</code></pre>

<h4 id="递归方法">递归方法</h4>

<pre><code class="language-php">&lt;?php
  function fib_recursive($n){
    if($n &lt; 0) return 0;
      elseif ($n == 1){
      return 1;
      }else{
      return fib_recursive($n-1) + fib_recursive($n-2);
      }
  }
</code></pre>

  </div>

  
  
<div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">petrie</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">0001-01-01</span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">License</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>


  
  
</article>




  
  

  

  

  
  
    



        </div>
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  
  
    <a href="mailto:lpfvip2008@gmail.com" rel="me noopener" class="iconfont"
      title="email" >
      <svg class="icon" viewBox="0 0 1451 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M664.781909 681.472759 0 97.881301C0 3.997201 71.046997 0 71.046997 0L474.477909 0 961.649408 0 1361.641813 0C1361.641813 0 1432.688811 3.997201 1432.688811 97.881301L771.345323 681.472759C771.345323 681.472759 764.482731 685.154773 753.594283 688.65053L753.594283 688.664858C741.602731 693.493018 729.424896 695.068979 718.077952 694.839748 706.731093 695.068979 694.553173 693.493018 682.561621 688.664858L682.561621 688.65053C671.644501 685.140446 664.781909 681.472759 664.781909 681.472759L664.781909 681.472759ZM718.063616 811.603883C693.779541 811.016482 658.879232 802.205449 619.10784 767.734955 542.989056 701.759633 0 212.052267 0 212.052267L0 942.809523C0 942.809523 0 1024 83.726336 1024L682.532949 1024 753.579947 1024 1348.948139 1024C1432.688811 1024 1432.688811 942.809523 1432.688811 942.809523L1432.688811 212.052267C1432.688811 212.052267 893.138176 701.759633 817.019477 767.734955 777.248 802.205449 742.347691 811.03081 718.063616 811.603883L718.063616 811.603883Z"></path>
</svg>

    </a>
  
    <a href="https://github.com/Petrie" rel="me noopener" class="iconfont"
      title="github"  target="_blank"
      >
      <svg class="icon" style="" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M512 12.672c-282.88 0-512 229.248-512 512 0 226.261333 146.688 418.133333 350.08 485.76 25.6 4.821333 34.986667-11.008 34.986667-24.618667 0-12.16-0.426667-44.373333-0.64-87.04-142.421333 30.890667-172.458667-68.693333-172.458667-68.693333C188.672 770.986667 155.008 755.2 155.008 755.2c-46.378667-31.744 3.584-31.104 3.584-31.104 51.413333 3.584 78.421333 52.736 78.421333 52.736 45.653333 78.293333 119.850667 55.68 149.12 42.581333 4.608-33.109333 17.792-55.68 32.426667-68.48-113.706667-12.8-233.216-56.832-233.216-253.013333 0-55.893333 19.84-101.546667 52.693333-137.386667-5.76-12.928-23.04-64.981333 4.48-135.509333 0 0 42.88-13.738667 140.8 52.48 40.96-11.392 84.48-17.024 128-17.28 43.52 0.256 87.04 5.888 128 17.28 97.28-66.218667 140.16-52.48 140.16-52.48 27.52 70.528 10.24 122.581333 5.12 135.509333 32.64 35.84 52.48 81.493333 52.48 137.386667 0 196.693333-119.68 240-233.6 252.586667 17.92 15.36 34.56 46.762667 34.56 94.72 0 68.522667-0.64 123.562667-0.64 140.202666 0 13.44 8.96 29.44 35.2 24.32C877.44 942.592 1024 750.592 1024 524.672c0-282.752-229.248-512-512-512"></path>
</svg>

    </a>


<a href="http://petrie.github.io/index.xml" rel="noopener alternate" type="application/rss&#43;xml"
    class="iconfont" title="rss" target="_blank">
    <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="30" height="30">
  <path d="M819.157333 1024C819.157333 574.592 449.408 204.8 0 204.8V0c561.706667 0 1024 462.293333 1024 1024h-204.842667zM140.416 743.04a140.8 140.8 0 0 1 140.501333 140.586667A140.928 140.928 0 0 1 140.074667 1024C62.72 1024 0 961.109333 0 883.626667s62.933333-140.544 140.416-140.586667zM678.784 1024h-199.04c0-263.210667-216.533333-479.786667-479.744-479.786667V345.173333c372.352 0 678.784 306.517333 678.784 678.826667z"></path>
</svg>

  </a>
  
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - <a class="theme-link" href="https://github.com/xianmin/hugo-theme-jane">Jane</a>
  </span>

  <span class="copyright-year">
    &copy;
    
      2015 -
    2020
    <span class="heart">
      
      <i class="iconfont">
        <svg class="icon" viewBox="0 0 1025 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="14" height="14">
  <path d="M1000.1 247.9c-15.5-37.3-37.6-70.6-65.7-98.9-54.4-54.8-125.8-85-201-85-85.7 0-166 39-221.4 107.4C456.6 103 376.3 64 290.6 64c-75.1 0-146.5 30.4-201.1 85.6-28.2 28.5-50.4 61.9-65.8 99.3-16 38.8-24 79.9-23.6 122.2 0.7 91.7 40.1 177.2 108.1 234.8 3.1 2.6 6 5.1 8.9 7.8 14.9 13.4 58 52.8 112.6 102.7 93.5 85.5 209.9 191.9 257.5 234.2 7 6.1 15.8 9.5 24.9 9.5 9.2 0 18.1-3.4 24.9-9.5 34.5-30.7 105.8-95.9 181.4-165 74.2-67.8 150.9-138 195.8-178.2 69.5-57.9 109.6-144.4 109.9-237.3 0.1-42.5-8-83.6-24-122.2z"
   fill="#8a8a8a"></path>
</svg>

      </i>
    </span><span class="author">
        petrie
        
      </span></span>

  
  
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont">
        
        <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="35" height="35">
  <path d="M510.866688 227.694839 95.449397 629.218702l235.761562 0-2.057869 328.796468 362.40389 0L691.55698 628.188232l241.942331-3.089361L510.866688 227.694839zM63.840492 63.962777l894.052392 0 0 131.813095L63.840492 195.775872 63.840492 63.962777 63.840492 63.962777zM63.840492 63.962777"></path>
</svg>

      </i>
    </div>
  </div>
  
<script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>




<script type="text/javascript" src="/js/main.638251f4230630f0335d8c6748e53a96f94b72670920b60c09a56fdc8bece214.js" integrity="sha256-Y4JR9CMGMPAzXYxnSOU6lvlLcmcJILYMCaVv3Ivs4hQ=" crossorigin="anonymous"></script>






  
    <script type="text/javascript" src="/js/load-photoswipe.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe.min.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe-ui-default.min.js"></script>
  













</body>
</html>
